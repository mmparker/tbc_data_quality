


<head>
<link rel="stylesheet" type="text/css" href="../css/tb_report.css">
</head>


```{r setup, echo= FALSE, warning= FALSE}

# Strings ain't factors
options(stringsAsFactors = FALSE)

# Load the required libraries
library(knitr)
library(xtable)
library(RODBC)
library(plyr)


# Set default chunk options
opts_chunk$set(echo = FALSE,
               results = 'asis',
               message = FALSE,
               warning = FALSE,
               error = TRUE)


# Source the data.frame pretty-printer
source(file.path("..", "fun", "dfprint.r"))



# Set up the database connection
if(interactive()) { 
    plus <- odbcConnect("tbdbplus64") 
} else {
    plus <- odbcConnect("tbdbplus32")
}
    



```



# TB Clinic Data Quality Report
Updated at `r paste(Sys.time())`



## Treatment Plan/Classification Mismatch
```{r plan_class_mismatch}

# Pull open plans
plantypes <- sqlQuery(plus, "
                  
    SELECT t.person_id, c.current_class,  t.treat_plan_type, 
           t.treat_plan_date, t.plan_author, t.plan_status
    FROM Tx_Plan_View t LEFT OUTER JOIN Case_Info_View c
    ON t.person_id = c.person_id
    WHERE t.plan_status = 'Open'
        AND author_affiliation = 'Denver Metro TB Clinic'
                      
")

# Flag discordant class/plans
plantypes$discordant <- FALSE

# Any treatment plan for the uninfected
plantypes$discordant[plantypes$current_class %in% c("Class 0", "Class 1") &
                     plantypes$treat_plan_type %in% c("LTBI", "Active")] <- TRUE

# Active plans for LTBI+
plantypes$discordant[plantypes$current_class %in% "Class 2" &
                     plantypes$treat_plan_type %in% "Active"] <- TRUE

# LTBI and Window plans for active cases and suspects
plantypes$discordant[plantypes$current_class %in% c("Class 3", "Class 5") &
                     plantypes$treat_plan_type %in% c("LTBI", "Window")] <- TRUE


#count(plantypes, c("current_class", "treat_plan_type", "discordant"))


discordant <- subset(plantypes,
                     subset = discordant,
                     select = c("person_id", "current_class", "treat_plan_type", 
                                "treat_plan_date", "plan_author", "plan_status")
)


dfprint(arrange(discordant, current_class, treat_plan_type))



```


## Patients with 2 or More Open Treatment Plans
```{r multiplan}

# Query the open plans by person_id
open_plans <- sqlQuery(plus, "
                      
    SELECT person_id, treat_plan, treat_plan_date, plan_status
    FROM Tx_Plan_View
    WHERE plan_status = 'Open'
        AND author_affiliation = 'Denver Metro TB Clinic'
                      
")

# Identify any person with multiple plans
multiplan_ids <- open_plans$person_id[duplicated(open_plans$person_id)]
multiplans <- subset(open_plans, person_id %in% multiplan_ids)

dfprint(arrange(multiplans, person_id, treat_plan_date))


```


## Treatment Plans Open Longer Than Expected
```{r plans_open_longer}

# Query the treatment plans
# Exclude plans prior to 2008
long_plans <- sqlQuery(plus, "
                  
    SELECT person_id, plan_author, treat_plan_date,
           treat_plan_type, ltbi_drug,
           latest_tx, plan_status, reason_stopped
    FROM Tx_Plan_View
    WHERE author_affiliation = 'Denver Metro TB Clinic'
        AND plan_status = 'Open'
        AND treat_plan_date > #2008-01-01#
                  
")

# Convert treat_plan_date to Date
long_plans$treat_plan_date <- as.Date(long_plans$treat_plan_date)

# Calculate how long each plan has been open
long_plans$days_open <- Sys.Date() - long_plans$treat_plan_date

# Flag those that have been open too long
# Rifampin - more than 4 months
# INH - more than 9 months
# INH/Rifapentine - more than 12 weeks
# Active - more than 12 months
long_plans$open_too_long <- FALSE
long_plans$open_too_long[long_plans$ltbi_drug %in% "RIF" & 
                             long_plans$days_open > 124] <- TRUE

long_plans$open_too_long[long_plans$ltbi_drug %in% "INH" & 
                             long_plans$days_open > 279] <- TRUE

long_plans$open_too_long[long_plans$ltbi_drug %in% "INH/Rifapentine" & 
                             long_plans$days_open > 84] <- TRUE

long_plans$open_too_long[long_plans$treat_plan_type %in% "Active" & 
                             long_plans$days_open > 365] <- TRUE

open_too_long <- subset(long_plans,
                        subset = open_too_long,
                        select = c("person_id", "plan_author",
                                   "treat_plan_type", "ltbi_drug",
                                   "treat_plan_date", "latest_tx",
                                   "plan_status", "reason_stopped", "days_open"))



dfprint(arrange(open_too_long, plan_author, treat_plan_type, ltbi_drug, desc(days_open)))



```


## Treatment Plans Closed Without Reason or End Date
```{r closed_without}


# Query the treatment plans
# Every plan should have a reason stopped. They should all have a treatment ending date,
# too, but to keep this list to a reasonable length I'll only pull completed plans that are
# missing end dates.
closed_without <- sqlQuery(plus, "
                  
    SELECT person_id, plan_author, treat_plan_date,
           treat_plan, plan_status, reason_stopped,
           treat_plan_end
    FROM Tx_Plan_View
    WHERE author_affiliation = 'Denver Metro TB Clinic'
        AND plan_status = 'Closed'
        AND (reason_stopped = 'Select One'
             OR (reason_stopped = 'Course Completed'
                 AND treat_plan_end Is Null
             )
        )
    ORDER BY plan_author, treat_plan_date
                  
")


dfprint(closed_without)


```


## Open Treatment Plans with Reason Stopped or End Date
```{r open_with}


# Query the treatment plans
# Every plan with a reason stopped or an end date should be closed
open_with <- sqlQuery(plus, "
                  
    SELECT person_id, plan_author, treat_plan_date,
           treat_plan, plan_status, reason_stopped,
           treat_plan_end
    FROM Tx_Plan_View
    WHERE author_affiliation = 'Denver Metro TB Clinic'
        AND plan_status = 'Open'
        AND (reason_stopped <> 'Select One'
             OR treat_plan_end Is Not Null)
    ORDER BY plan_author, treat_plan_date
                  
")


dfprint(arrange(open_with, reason_stopped))


```


## Incomplete LTBI Pickups in the Past Fourteen Days
```{r missed_pickups}

# Query the missed LTBI pickups from the last fourteen days
missed_pu <- sqlQuery(plus, paste("
                                  
    SELECT t.person_id, p.last_name, p.first_name, t.treatment_date
    FROM Drug_Treatment t LEFT OUTER JOIN Person p
    ON t.person_id = p.idnumber
    WHERE dispense_type = 'Pickup'
        AND completed = ''
        AND treatment_date BETWEEN (Now() - 14) AND (Now() - 1)
    ORDER BY treatment_date",
                                  
    sep = "")
                      
)
                                  

dfprint(missed_pu)


```



## Suspects Open for More Than 90 Days
```{r overdue_suspects}

# Query the Case Info records of suspects associated with our clinic
# Ignore any with a status set before 2007
suspects <- sqlQuery(plus, "

    SELECT person_id,
           case_status,
           current_status, 
           current_status_date,
             DATE() - current_status_date AS days_since_status,
		       case_manager
    FROM Case_Info_View
    WHERE current_status = '(Class 5 ) TB Suspect'
        AND case_manager Is Not Null 
        AND agency IN ('Denver Public Health - Metro TB Clinic', 'Select One')
    ORDER BY case_manager, current_status_date
                      
")

# Convert that dt to a date
suspects$current_status_date <- as.Date(suspects$current_status_date)


# Identify suspects to close
suspects$to_close <- FALSE

# Suspects prior to 2007 can stay suspects, but should be closed
suspects$to_close[suspects$current_status_date < as.Date("2007-01-01") &
                  suspects$case_status %in% "Open"] <- TRUE

# Suspects with no status date should also be closed, if possible
suspects$to_close[is.na(suspects$current_status_date) &
                  suspects$case_status %in% "Open"] <- TRUE

# Finally, for cases after 2007, anyone suspected over 90 days should be reclassified
suspects$to_close[suspects$current_status_date >= as.Date("2007-01-01") &
                  suspects$days_since_status > 90] <- TRUE



# Subset to suspects to close, and drop the to_close column
suspects_to_close <- suspects[suspects$to_close, !names(suspects) %in% "to_close"]


dfprint(suspects_to_close)

```





## TSTs with Missing Results
```{r tsts_missing_results}

# Query TSTs either placed or read by our staff but without results
# Disregard tests placed before 2009
tsts_no_result <- sqlQuery(plus, "
                 
    SELECT person_id, date_given, date_read, tst_read_by, result
    FROM TST_View
    WHERE reader_affiliation = 'Denver Metro TB Clinic'
        AND result = 'Select One'
        AND date_given >= #2009-01-01#
    ORDER BY tst_read_by, date_given
                 
")

dfprint(subset(tsts_no_result, as.Date(date_given) < (Sys.Date() - 3)))


```


## QFTs with Missing Results
```{r qfts_missing_results}

# Query the DPH QFTs
qfts_no_result <- sqlQuery(plus, "
                 
    SELECT person_id, lab, collection_date, result
    FROM QFT_View
    WHERE lab = 'Denver Public Health'
        AND result = 'Select One'
                 
")

# Convert the collection date
qfts_no_result$date_collected <- as.Date(qfts_no_result$collection_date, 
                                         format = "%m/%d/%Y")


qfts_no_result_print <- subset(qfts_no_result,
                               subset = date_collected < (Sys.Date() - 2),
                               select = !names(qfts_no_result) %in% "collection_date"
)

dfprint(arrange(qfts_no_result_print, date_collected))


```






## Clinical Encounters with No Staff Responsible
```{r encounters_nostaff}

# Query encounters with no staff responsible (clinical only - don't worry about admin)
no_staff <- sqlQuery(plus, "
                     
    SELECT person_id, eval_date, eval_category, updated_by
    FROM Eval_View
    WHERE staff_responsible Is Null
        AND eval_category = 'Clinical'
        AND updated_by IN (
            SELECT staff_userid
            FROM Def_staff
            WHERE affiliation = 'Denver Metro TB Clinic'
            )
    ORDER BY updated_by, eval_date
                     
")

dfprint(no_staff)

```






## Visits with No Location
```{r no_location}

# Query encounters with visit_location = 0 ("Select One").
# Only pull face-to-face encounters - that's eval_category = 'Clinical'
# Ignore the NAs - those are imported records that predate TBdb.
enc <- sqlQuery(plus, "
                
    SELECT person_id, eval_date, staff_responsible
    FROM Eval_View
    WHERE visit_location = 'Select One'
        AND eval_category = 'Clinical'
        AND eval_date >= #2011-01-01#
        AND staff_affiliation = 'Denver Metro TB Clinic'
    ORDER BY staff_responsible, eval_date
                
")

dfprint(enc)


```



## Addresses with No County
```{r no_county}

# Query addresses with no county indicated
# Ignore the really old ones
# Colorado cities only
no_county <- sqlQuery(plus, "
                      
    SELECT a.person_id, a.address, a.city, d.county,
           a.updated_by, a.updated_date
    FROM Addresses a LEFT OUTER JOIN Def_county d
    ON a.county = d.county_of_residence
    WHERE (d.county = 'Unknown'
           OR d.county Is Null)
        AND a.updated_date > #2010-01-01#
        AND a.state = 'CO'
        AND a.updated_by IN (
            SELECT staff_userid
            FROM Def_staff
            WHERE affiliation = 'Denver Metro TB Clinic'
            )
    ORDER BY a.updated_by, a.updated_date

")

dfprint(no_county)

```













```{r cleanup}

# Close the database connection
odbcClose(plus)


```



